                        ; Defined if we are running slow:
                        
                        
                        ; Defined to turn off printing:
                        
                        
                        ; library.asm must be first!
                        
                        ;
                        ; Commonly used assembly routines
                        ;
                        
                        ; 8259 Constants
   0000                 I8259A EQU 000H ; 8259 port 1
   0001                 I8259B EQU 001H ; 8259 port 2
                        
                        ;
                        ; LCD Constants
                        ;
   0002                 LCDINST EQU 002H ; LCD instruction I/O port
   0003                 LCDDATA EQU 003H ; LCD data I/O port
   0001                 LCLEAR EQU 001H ; LCD clear instruction
   0038                 LRESET EQU 038H ; LCD reset to normal instruction
   0080                 LHALF1 EQU 080H ; LCD move cursor to char 1
   00c0                 LHALF2 EQU 0c0H ; LCD move cursor to char 9
   000a                 PAUSE EQU 0aH ; a UNIX newline
   0000                 STACKTOP EQU 00000H ; top of stack (wraps to 0ffff)
                        
                        ; PIC Constants
   0004                 PIC EQU 004H ; PIC I/O port
                        
                        ;
                        ; Set up useful stuff, jump to main program
                        ;
   0000   31 00 00       LD SP, STACKTOP
   0003   cd 4c 00       CALL LCDINIT
   0006   c3 cb 01       JP MAIN ; get past library routines
                        
                        ;
                        ; Catch reset if it happens and try to print it on the LCD
                        ;
                        
   0038                  ORG 0038H ; Catch a reset
   0038   21 3f 00       LD HL, GOTRESETSTR
   003b   cd 89 00       CALL LCDPRINT
   003e   76             HALT
                        
   003f   47 6f 74 20   GOTRESETSTR DB "Got RST 38H", PAUSE, 0
   0043   52 53 54 20   
   0047   33 38 48 0a   
   004b   00            
                        
                        
                        ;
                        ; LCD Init routine
                        ; In: nothing
                        ;
   004c                 LCDINIT
                        
                        
                        
                        
   004c   c5             PUSH BC
   004d   e5             PUSH HL
                        
   004e   21 6b 00       LD HL, LISTRING
   0051   06 0a          LD B, LISTRLEN
                        
   0053   c3 58 00       JP OUTBLOOP
                        
                        ;
                        ; LCD string bytes output routine
                        ; In:
                        ; B - length divided by two, (e.g. # of bytes to output, not
                        ; including the I/O addresses)
                        ; HL - address of bytes
                        ;
   0056                 OUTBYTES
   0056   c5             PUSH BC
   0057   e5             PUSH HL
                        
   0058                 OUTBLOOP
   0058   4e             LD C, (HL)
   0059   23             INC HL
   005a   ed a3          OUTI
   005c   20 fa          JR NZ, OUTBLOOP
                        
                         ; Probably need a delay here at 1 MHz.
                         ; Are we supposed to check busy bit and wait until not busy?
                        
   005e   e1             POP HL
   005f   c1             POP BC
                        
   0060   c9             RET
                        
                        ;
                        ; Clear LCD display
                        ; In: nothing
                        ;
   0061                 LCDCLR
   0061   c5             PUSH BC
   0062   e5             PUSH HL
                        
   0063   21 7f 00       LD HL, LCSTRING
   0066   06 05          LD B, LCSTRLEN ; falls through into byte output loop
   0068   c3 58 00       JP OUTBLOOP
                        
                        ;
                        ; LCD Initialization string
                        ;
   000a                 LISTRLEN EQU 10
   006b                 LISTRING
   006b   02 38          DB LCDINST, LRESET
   006d   02 38          DB LCDINST, LRESET
   006f   02 06          DB LCDINST, 006H
   0071   02 0e          DB LCDINST, 00eH
   0073   02 01          DB LCDINST, LCLEAR
   0075   02 80          DB LCDINST, LHALF1
   0077   02 80          DB LCDINST, LHALF1
   0079   02 80          DB LCDINST, LHALF1
   007b   02 80          DB LCDINST, LHALF1
   007d   02 80          DB LCDINST, LHALF1
                        
   0005                 LCSTRLEN EQU 5
   007f                 LCSTRING
   007f   02 01          DB LCDINST, LCLEAR
   0081   02 80          DB LCDINST, LHALF1
   0083   02 80          DB LCDINST, LHALF1
   0085   02 80          DB LCDINST, LHALF1
   0087   02 80          DB LCDINST, LHALF1
                        
                        ;
                        ; LCD String output routine
                        ; In:
                        ; HL - Address of null-terminated string
                        ;
   0089                 LCDPRINT
                        
                        
                        
                        
   0089   f5             PUSH AF
   008a   c5             PUSH BC
   008b   d5             PUSH DE
   008c   e5             PUSH HL
                        
   008d   3e 01          LD A, LCLEAR
   008f   d3 02          OUT (LCDINST), A ; do a clear
                        
                        
   0091   06 fa          LD B, 250 ; 250 cycles of wait
   0093                 LCDPCLOOP
   0093   10 fe          DJNZ LCDPCLOOP
                        
                        
   0095   0e 03          LD C, LCDDATA
   0097   16 19          LD D, 25 ; when 1->0, switch to 2nd display
                        
   0099                 LCDPLOOP
   0099   15             DEC D
   009a   c2 a5 00       JP NZ, LCDNOSWITCH
                        
   009d   3e c0          LD A, LHALF2 ; set LCD to address 0xc0
   009f   d3 02          OUT (LCDINST), A
                        
                        
   00a1   06 14          LD B, 20 ; 20 cycles of wait for write to LCD
   00a3                 LCDP2LOOP
   00a3   10 fe          DJNZ LCDP2LOOP ; fall through
                        
                        
   00a5                 LCDNOSWITCH
                        
   00a5   7e             LD A, (HL)
   00a6   fe 00          CP 0
   00a8   ca df 00       JP Z, LCDPDONE
                        
   00ab   fe 0a          CP PAUSE
   00ad   c2 d5 00       JP NZ, LCDPDOIT
                        
                        ; LD A, 0dh ; return
                        ; OUT (PIC), A
                        
                        
                         ; wait for two seconds here!
   00b0   16 02          LD D, 2 ; 2 * 256 * 256 cycles is close to 1 sec
   00b2                 LCDP1SL1
   00b2   3e 00          LD A, 0 ; 256 * 256 cycles
   00b4                 LCDP1SL2
   00b4   06 00          LD B, 0 ; 256 cycles
   00b6                 LCDP1SL3
   00b6   10 fe          DJNZ LCDP1SL3
                        
   00b8   3d             DEC A
   00b9   c2 b4 00       JP NZ, LCDP1SL2
                        
   00bc   15             DEC D
   00bd   c2 b2 00       JP NZ, LCDP1SL1
                        
                        
   00c0   3e 01          LD A, LCLEAR
   00c2   d3 02          OUT (LCDINST), A ; do a clear
                        
                        ; LD A, 0ah ; linefeed
                        ; OUT (PIC), A
                        
                        
   00c4   06 fa          LD B, 250 ; 250 cycles of wait
   00c6                 LCDPNLOOP
   00c6   10 fe          DJNZ LCDPNLOOP
                        
                        
   00c8   3e 80          LD A, LHALF1
   00ca   d3 02          OUT (LCDINST), A ; go to address 0x80
                        
                        
   00cc   06 14          LD B, 20 ; 20 cycles of wait for write
   00ce                 LCDP1LOOP
   00ce   10 fe          DJNZ LCDP1LOOP
                        
                        
   00d0   16 09          LD D, 9 ; reset half counter
   00d2   c3 db 00       JP LCDPNEXT ; continue with next character
                        
   00d5                 LCDPDOIT
   00d5   d3 03          OUT (LCDDATA), A ; output that guy
                        ; OUT (PIC), A
                        
                        
   00d7   06 14          LD B, 20 ; 20 cycles of wait for write
   00d9                 LCDPWLOOP
   00d9   10 fe          DJNZ LCDPWLOOP
                        
                        
   00db                 LCDPNEXT
   00db   23             INC HL ; next char
   00dc   c3 99 00       JP LCDPLOOP
                        
   00df                 LCDPDONE
                        
   00df   e1             POP HL
   00e0   d1             POP DE
   00e1   c1             POP BC
   00e2   f1             POP AF
                        
   00e3   c9             RET
                        
                        
                        ;
                        ; Wait for seconds routine
                        ; In:
                        ; A - number of seconds to wait
                        ;
   00e4                 WAITSECS
   00e4   f5             PUSH AF
   00e5   c5             PUSH BC
   00e6   07             RLCA ; multiply A by 2
                        
   00e7                 LCDP1SLP1
   00e7   0e 00          LD C, 0 ; 256 * 256 cycles
   00e9                 LCDP1SLP2
   00e9   06 00          LD B, 0 ; 256 cycles
   00eb                 LCDP1SLP3
   00eb   10 fe          DJNZ LCDP1SLP3
                        
   00ed   0d             DEC C
   00ee   c2 e9 00       JP NZ, LCDP1SLP2
                        
   00f1   3d             DEC A
   00f2   c2 e7 00       JP NZ, LCDP1SLP1
                        
   00f5   c1             POP BC
   00f6   f1             POP AF
                        
   00f7   c9             RET
                        
                        
                        ;
                        ; put the hex string representation of A into the location at IX
                        ; IX becomes IX + 2
                        ;
   00f8                 PHEXBYTE
   00f8   f5             PUSH AF
   00f9   c5             PUSH BC
                        
   00fa   47             LD B, A
   00fb   e6 f0          AND 0f0H
   00fd   cb 3f          SRL A
   00ff   cb 3f          SRL A
   0101   cb 3f          SRL A
   0103   cb 3f          SRL A
   0105   fe 0a          CP 0aH
   0107   da 0f 01       JP C, DIG1LESS
   010a   c6 57          ADD A, "a" - 10
   010c   c3 11 01       JP DIG1DONE
   010f                 DIG1LESS
   010f   c6 30          ADD A, "0"
   0111                 DIG1DONE
                        
   0111   dd 77 00       LD (IX), A
   0114   dd 23          INC IX
   0116   78             LD A, B
   0117   e6 0f          AND 0fH
   0119   fe 0a          CP 0aH
   011b   da 23 01       JP C, DIG2LESS
   011e   c6 57          ADD A, "a" - 10
   0120   c3 25 01       JP DIG2DONE
   0123                 DIG2LESS
   0123   c6 30          ADD A, "0"
   0125                 DIG2DONE
   0125   dd 77 00       LD (IX), A
   0128   dd 23          INC IX
                        
   012a   c1             POP BC
   012b   f1             POP AF
   012c   c9             RET
                        
                        ;
                        ; put the hex string representation of HL into the location at IX
                        ; IX becomes IX + 4
                        ;
   012d                 PHEXWORD
                        
   012d   f5             PUSH AF
   012e   7c             LD A, H
   012f   cd f8 00       CALL PHEXBYTE
   0132   7d             LD A, L
   0133   cd f8 00       CALL PHEXBYTE
   0136   f1             POP AF
   0137   c9             RET
                        
                        
                        ;
                        ; GETS - Inputs a string into the
                        ; buffer pointed to by HL. String is
                        ; NULL-terminated.
                        ;
                        ; No registers are modified.
                        ;
                        
   0138                 GETS
   0138   f5             PUSH AF
   0139   e5             PUSH HL
   013a   c5             PUSH BC
   013b   d5             PUSH DE
   013c   dd e5          PUSH IX
   013e   fd e5          PUSH IY
                        
   0140   e5             PUSH HL
   0141   dd e1          POP IX ; IX = end of buffer
   0143   dd 36 00 00    LD (IX), 0
                        
   0147                 GETS_LOOP ; wait for key
   0147   3a 01 80       LD A, (NUMKEY)
   014a   fe 00          CP 0
   014c   c2 5b 01       JP NZ, GOT_KEY
                        
   014f   3a 0d 80       LD A, (SHOULD_RUN)
   0152   fe 00          CP 0
   0154   ca 47 01       JP Z, GETS_LOOP
                        
                         ; comment this in for the next burn-in
                         ; LD A, 0
                         ; LD (SHOULD_RUN), A
                        
   0157   2a 09 80       LD HL, (CURRENT_ADDR)
   015a   e9             JP (HL)
                        
   015b                 GOT_KEY
   015b   f3             DI
   015c   3a 01 80       LD A, (NUMKEY) ; in case it changed before DI
   015f   fd 21 00 a0    LD IY, KEYBUF
   0163   47             LD B, A
                        
   0164                 GETS_COPY
   0164   fd 7e 00       LD A, (IY)
                        
   0167   fe 08          CP 8 ; backspace
   0169   ca 71 01       JP Z, BACKSPACE
   016c   fe 7f          CP 127 ; delete
   016e   c2 82 01       JP NZ, NOT_BACKSPACE
                        
   0171                 BACKSPACE
                         ; do not backspace past beginning of buffer
   0171   dd e5          PUSH IX ; move IX into DE
   0173   d1             POP DE
   0174   37             SCF ; carry = 1
   0175   3f             CCF ; carry = 0
   0176   e5             PUSH HL ; save HL
   0177   ed 52          SBC HL, DE ; HL -= DE
   0179   e1             POP HL ; restore HL
   017a   ca 87 01       JP Z, NEXT_KEY ; do not backspace if IX == HL
                        
   017d   dd 2b          DEC IX
   017f   c3 87 01       JP NEXT_KEY
                        
   0182                 NOT_BACKSPACE
   0182   dd 77 00       LD (IX), A
   0185   dd 23          INC IX
                        
   0187                 NEXT_KEY
   0187   fe 0a          CP 10 ; return (keyboard)
   0189   ca a5 01       JP Z, GETS_DONE
                        
   018c   fe 0d          CP 13 ; return (maybe serial)
   018e   ca a5 01       JP Z, GETS_DONE
                        
   0191   fd 23          INC IY
                        
   0193   10 cf          DJNZ GETS_COPY
                        
   0195   3e 00          LD A, 0
   0197   32 01 80       LD (NUMKEY), A
   019a   fb             EI
                        
   019b   dd 36 00 00    LD (IX), 0
   019f   cd 89 00       CALL LCDPRINT
                        
   01a2   c3 47 01       JP GETS_LOOP
                        
   01a5                 GETS_DONE
   01a5   3e 00          LD A, 0
   01a7   32 01 80       LD (NUMKEY), A
   01aa   fb             EI
                        
   01ab   dd 36 00 00    LD (IX), 0
                        
   01af   fd e1          POP IY
   01b1   dd e1          POP IX
   01b3   d1             POP DE
   01b4   c1             POP BC
   01b5   e1             POP HL
   01b6   f1             POP AF
   01b7   c9             RET
                        
                        ;----------------------------------------
                        
                        ;
                        ; STRCPY - Copies HL into IX.
                        ;
                        ; Leaves IX at terminating 0. No other
                        ; registers are modified.
                        ;
                        ;
                        ;
                        
   01b8                 STRCPY
   01b8   e5             PUSH HL
   01b9   f5             PUSH AF
                        
   01ba                 STRCPY_LOOP
   01ba   7e             LD A, (HL)
   01bb   dd 77 00       LD (IX), A
   01be   23             INC HL
   01bf   dd 23          INC IX
                        
   01c1   fe 00          CP 0
   01c3   c2 ba 01       JP NZ, STRCPY_LOOP
                        
   01c6   dd 2b          DEC IX
                        
   01c8   f1             POP AF
   01c9   e1             POP HL
   01ca   c9             RET
                        
                        ;----------------------------------------
                        
   8000                 PIC_COMMAND EQU 08000H
   8001                 NUMKEY EQU 08001H
   8003                 PICBYTE EQU 08003H
   8004                 SHIFT_STATUS EQU 08004H
   8005                 CTRL_STATUS EQU 08005H
   8006                 ALT_STATUS EQU 08006H
   8007                 UPKEY_FLAG EQU 08007H
   8008                 CURRENT_CMD EQU 08008H
   8009                 CURRENT_ADDR EQU 08009H ; two bytes
   800b                 CURRENT_LEN EQU 0800BH
   800c                 CURRENT_PTR EQU 0800CH ; point into CURRENT_CMD
   800d                 SHOULD_RUN EQU 0800DH
   a000                 KEYBUF EQU 0A000H
   c000                 INPUT_BUF EQU 0C000H
   c040                 OUTPUT_BUF EQU 0C040H
                        
   0012                 LSHIFT_KEY EQU 012H
   0059                 RSHIFT_KEY EQU 059H
   0014                 CTRL_KEY EQU 014H
   0011                 ALT_KEY EQU 011H
   00f0                 UP_KEY EQU 0F0H
   00e0                 EXT_KEY EQU 0E0H
   00e1                 EXT2_KEY EQU 0E1H
                        
   0000                 PIC_NON_CMD EQU 000H
   0001                 PIC_SER_CMD EQU 001H
   0002                 PIC_KBD_CMD EQU 002H
   0003                 PIC_TIM_CMD EQU 003H
                        
   0001                 CMD_SEND EQU 001H
   0002                 CMD_RUN EQU 002H
   0003                 CMD_MAX EQU 003H ; one past max value of a command
                        
                        
                        ;----------------------------------------
                        
                        ;
                        ; Memory test program
                        ;
                        
   01cb                 MAIN
   01cb   21 b4 03       LD HL, INTROSTR
   01ce   cd 89 00       CALL LCDPRINT
                        
                        ;
                        ; Setup the 8259
                        ;
                        
   01d1   3e 16          LD A, 016H ; F = 1, S = 1
   01d3   d3 00          OUT (I8259A), A
                        
   01d5   3e 3f          LD A, 03FH ; Table is at 03F00H
   01d7   d3 01          OUT (I8259B), A
                        
   01d9   3e f0          LD A, 0F0H ; Enable lower 4 IRQs
   01db   d3 01          OUT (I8259B), A
                        
                        ;
                        ; Initialize our variables
                        ;
                        
   01dd   3e 00          LD A, 0
   01df   32 00 80       LD (PIC_COMMAND), A
   01e2   32 01 80       LD (NUMKEY), A
   01e5   32 04 80       LD (SHIFT_STATUS), A
   01e8   32 05 80       LD (CTRL_STATUS), A
   01eb   32 06 80       LD (ALT_STATUS), A
   01ee   32 07 80       LD (UPKEY_FLAG), A
   01f1   32 0c 80       LD (CURRENT_PTR), A
   01f4   32 0d 80       LD (SHOULD_RUN), A
                        
                        ;
                        ; Read a byte from the pic in case it triggered
                        ; an interrupt before we were ready (keyboard
                        ; reset). This resets the PIC interrupt line.
                        ;
                        ; The command read routine throws away commands it does not understand,
                        ; so it is likely we will get the keyboard init status byte here but the
                        ; command read routine will chuck it and we will catch up on the next byte.
                        ;
                        
   01f7   db 04          IN A, (PIC)
                        
                        ;
                        ; Setup interrupt mode 0
                        ;
                        
   01f9   ed 46          IM 0
   01fb   fb             EI
                        
                        ;
                        ; Go, go, go!
                        ;
                        
   01fc   c3 00 30              JP ZCCOUT
                        
   01ff                 PRINTAGAIN
   01ff   21 c3 03       LD HL, PLEASESTR
   0202   cd 89 00       CALL LCDPRINT
                        
   0205   21 00 c0       LD HL, INPUT_BUF
   0208   cd 38 01       CALL GETS
                        
   020b   21 cf 03       LD HL, HELLOSTR
   020e   dd 21 40 c0    LD IX, OUTPUT_BUF
   0212   cd b8 01       CALL STRCPY
                        
   0215   21 00 c0       LD HL, INPUT_BUF
   0218   cd b8 01       CALL STRCPY
                        
   021b   dd 36 00 0a    LD (IX), PAUSE
   021f   dd 23          INC IX
   0221   dd 36 00 00    LD (IX), 0
                        
   0225   21 40 c0       LD HL, OUTPUT_BUF
   0228   cd 89 00       CALL LCDPRINT
                        
   022b   c3 ff 01       JP PRINTAGAIN
                        
                        ;----------------------------------------
                        
   022e                 ISR0 ; PIC interrupt
                        
                         ;
                         ; The PIC sends a command byte followed by an
                         ; optional data byte.
                         ;
                         ; Command byte: PIC_SER_CMD
                         ; Data byte: serial byte in ASCII
                         ;
                         ; Command byte: PIC_KBD_CMD
                         ; Data byte: keyboard byte as scan code
                         ;
                         ; Command byte: PIC_TIM_CMD
                         ; Data byte: none
                         ;
                         ; Current command is stored in PIC_COMMAND, which is
                         ; equal to PIC_NON_CMD if we are waiting for a command.
                         ;
                        
   022e   f5             PUSH AF
                        
   022f   db 04          IN A, (PIC)
   0231   32 03 80       LD (PICBYTE), A
                        
                        ; START TEST
                        ; END TEST
                        
   0234   3a 00 80       LD A, (PIC_COMMAND)
   0237   fe 00          CP PIC_NON_CMD ; Cmd not read yet
   0239   ca 49 02       JP Z, ISR0_IS_COMMAND
                        
   023c   fe 01          CP PIC_SER_CMD
   023e   ca 5a 02       JP Z, ISR0_IS_SERIAL
                        
   0241   fe 02          CP PIC_KBD_CMD
   0243   ca 60 02       JP Z, ISR0_IS_KEYBOARD
                        
   0246   c3 66 02       JP ISR0_RESET ; Whoa, bad byte
                        
   0249                 ISR0_IS_COMMAND
   0249   3a 03 80       LD A, (PICBYTE)
   024c   fe 03          CP PIC_TIM_CMD ; special case for timer cause no data
   024e   ca 57 02       JP Z, ISR0_IS_TIMER
                        
   0251   32 00 80       LD (PIC_COMMAND), A
   0254   c3 6b 02       JP ISR0_END
                        
   0257                 ISR0_IS_TIMER
                         ; do something
   0257   c3 66 02       JP ISR0_RESET
                        
   025a                 ISR0_IS_SERIAL
   025a   cd 72 02       CALL HANDLE_SERIAL
   025d   c3 66 02       JP ISR0_RESET
                        
   0260                 ISR0_IS_KEYBOARD
   0260   cd e7 02       CALL HANDLE_KEYBOARD
   0263   c3 66 02       JP ISR0_RESET
                        
   0266                 ISR0_RESET
   0266   3e 00          LD A, PIC_NON_CMD
   0268   32 00 80       LD (PIC_COMMAND), A
                         ; FALLTHROUGH
                        
   026b                 ISR0_END
   026b   3e 20          LD A, 020H ; End of Interrupt
   026d   d3 00          OUT (I8259A), A
                        
   026f   f1             POP AF
   0270   fb             EI
   0271   c9             RET
                        
                        ;------------------
                        
   0272                 HANDLE_SERIAL ; trashes A
   0272   e5             PUSH HL
   0273   c5             PUSH BC
                        
                         ; we get downloaded programs through serial. handle
                         ; that first. we get one command byte, then two
                         ; address bytes, then a length byte. if the command
                         ; is CMD_SEND, then this header is followed by "length"
                         ; bytes to stick into "address". if the command is
                         ; CMD_RUN, then the length is zero and SHOULD_RUN is
                         ; set to 1, which causes the input routine to jump
                         ; to the address in CURRENT_ADDR.
                        
   0274   3a 0c 80       LD A, (CURRENT_PTR)
   0277   fe 03          CP 3
   0279   c2 8c 02       JP NZ, GET_CMD_HEADER
                        
                         ; just got last byte of header
   027c   3a 08 80       LD A, (CURRENT_CMD)
   027f   fe 02          CP CMD_RUN
   0281   c2 8c 02       JP NZ, GET_CMD_HEADER
                        
                         ; ignore length and run
   0284   3e 01          LD A, 1
   0286   32 0d 80       LD (SHOULD_RUN), A
   0289   c3 e4 02       JP END_HANDLE_SERIAL
                        
   028c                 GET_CMD_HEADER
   028c   3a 0c 80       LD A, (CURRENT_PTR)
   028f   fe 04          CP 4
   0291   ca b7 02       JP Z, TRANSFER_BYTE
                        
                         ; check if it is not a transfer
   0294   fe 00          CP 0
   0296   c2 a1 02       JP NZ, TRANSFER_HEADER
                        
   0299   3a 03 80       LD A, (PICBYTE)
   029c   fe 03          CP CMD_MAX
   029e   f2 d2 02       JP P, SIMULATE_KEYBOARD ; >= CMD_MAX
                        
   02a1                 TRANSFER_HEADER
                         ; transfer into the header
   02a1   21 08 80       LD HL, CURRENT_CMD
   02a4   3a 0c 80       LD A, (CURRENT_PTR)
   02a7   4f             LD C, A
   02a8   06 00          LD B, 0
   02aa   09             ADD HL, BC
   02ab   3a 03 80       LD A, (PICBYTE)
   02ae   77             LD (HL), A
   02af   0c             INC C
   02b0   79             LD A, C
   02b1   32 0c 80       LD (CURRENT_PTR), A
                        
   02b4   c3 e4 02       JP END_HANDLE_SERIAL
                        
   02b7                 TRANSFER_BYTE
                         ; transfer into RAM
   02b7   2a 09 80       LD HL, (CURRENT_ADDR)
   02ba   3a 03 80       LD A, (PICBYTE)
   02bd   77             LD (HL), A
   02be   23             INC HL
   02bf   22 09 80       LD (CURRENT_ADDR), HL
   02c2   3a 0b 80       LD A, (CURRENT_LEN)
   02c5   3d             DEC A
   02c6   32 0b 80       LD (CURRENT_LEN), A
   02c9   c2 e4 02       JP NZ, END_HANDLE_SERIAL
                        
   02cc   32 0c 80       LD (CURRENT_PTR), A
                        
   02cf   c3 e4 02       JP END_HANDLE_SERIAL
                        
   02d2                 SIMULATE_KEYBOARD
   02d2   21 00 a0       LD HL, KEYBUF
   02d5   3a 01 80       LD A, (NUMKEY)
   02d8   4f             LD C, A
   02d9   06 00          LD B, 0
   02db   09             ADD HL, BC ; HL = pointer into buffer
   02dc   3c             INC A
   02dd   32 01 80       LD (NUMKEY), A
                        
   02e0   3a 03 80       LD A, (PICBYTE) ; Key in A
   02e3   77             LD (HL), A ; Stick our letter in buffer
                        
   02e4                 END_HANDLE_SERIAL
                        
   02e4   c1             POP BC
   02e5   e1             POP HL
   02e6   c9             RET
                        
                        ;------------------
                        
   02e7                 HANDLE_KEYBOARD
   02e7   e5             PUSH HL
   02e8   c5             PUSH BC
                        
   02e9   3a 03 80       LD A, (PICBYTE) ; Get the byte
                        
   02ec   fe f0          CP UP_KEY ; Key-up is preceded by UP_KEY
   02ee   c2 f9 02       JP NZ, NOT_UP_KEY
                        
   02f1   3e 01          LD A, 1
   02f3   32 07 80       LD (UPKEY_FLAG), A
   02f6   c3 79 03       JP END_HANDLE_KEYBOARD
                        
   02f9                 NOT_UP_KEY
   02f9   fe e0          CP EXT_KEY ; Extended keys preceded by EXT_KEY
   02fb   ca 74 03       JP Z, DID_KEY ; For now just ignore
                        
   02fe   fe e1          CP EXT2_KEY ; Break preceded by EXT2_KEY
   0300   ca 74 03       JP Z, DID_KEY ; For now just ignore
                        
   0303   cb 7f          BIT 7, A ; See if high bit is on
   0305   c2 74 03       JP NZ, DID_KEY ; Ignore if >= 128
                        
   0308   fe 12          CP LSHIFT_KEY ; See if it is a shift key
   030a   ca 12 03       JP Z, IS_SHIFT
   030d   fe 59          CP RSHIFT_KEY
   030f   c2 1d 03       JP NZ, NOT_SHIFT
   0312                 IS_SHIFT
   0312   3a 07 80       LD A, (UPKEY_FLAG)
   0315   ee 01          XOR 1
   0317   32 04 80       LD (SHIFT_STATUS), A
   031a   c3 74 03       JP DID_KEY
                        
   031d                 NOT_SHIFT
   031d   fe 14          CP CTRL_KEY ; See if it is a control key
   031f   c2 2d 03       JP NZ, NOT_CTRL
                        
   0322   3a 07 80       LD A, (UPKEY_FLAG)
   0325   ee 01          XOR 1
   0327   32 05 80       LD (CTRL_STATUS), A
   032a   c3 74 03       JP DID_KEY
                        
   032d                 NOT_CTRL
   032d   fe 11          CP ALT_KEY ; See if it is an alt key
   032f   c2 3d 03       JP NZ, NOT_ALT
                        
   0332   3a 07 80       LD A, (UPKEY_FLAG)
   0335   ee 01          XOR 1
   0337   32 06 80       LD (ALT_STATUS), A
   033a   c3 74 03       JP DID_KEY
                        
   033d                 NOT_ALT
   033d   6f             LD L, A ; HL = A
   033e   26 00          LD H, 0
                        
   0340   3a 07 80       LD A, (UPKEY_FLAG) ; Ignore all other key ups
   0343   fe 01          CP 1
   0345   ca 74 03       JP Z, DID_KEY
                        
   0348   29             ADD HL, HL ; HL *= 4
   0349   29             ADD HL, HL
                        
   034a   06 00          LD B, 0
   034c   3a 04 80       LD A, (SHIFT_STATUS)
   034f   4f             LD C, A
   0350   09             ADD HL, BC
                        
   0351   3a 05 80       LD A, (CTRL_STATUS)
   0354   4f             LD C, A
   0355   09             ADD HL, BC
   0356   09             ADD HL, BC
                        
   0357   3a 06 80       LD A, (ALT_STATUS)
   035a   4f             LD C, A
   035b   09             ADD HL, BC
   035c   09             ADD HL, BC
   035d   09             ADD HL, BC
                        
   035e   01 d6 03       LD BC, KEY_XLAT ; Translation table
   0361   09             ADD HL, BC
                        
   0362   7e             LD A, (HL) ; Get actual key
   0363   f5             PUSH AF
                        
   0364   21 00 a0       LD HL, KEYBUF
   0367   3a 01 80       LD A, (NUMKEY)
   036a   4f             LD C, A
   036b   06 00          LD B, 0
   036d   09             ADD HL, BC ; HL = pointer into buffer
   036e   3c             INC A
   036f   32 01 80       LD (NUMKEY), A
                        
   0372   f1             POP AF ; Key in A
   0373   77             LD (HL), A ; Stick our ASCII letter in there
                        
                        
   0374                 DID_KEY
                         ; Reset "up" flag
   0374   3e 00          LD A, 0
   0376   32 07 80       LD (UPKEY_FLAG), A
                        
   0379                 END_HANDLE_KEYBOARD
                        
   0379   c1             POP BC
   037a   e1             POP HL
   037b   c9             RET
                        
                        ;------------------
                        
   037c                 ISR1
   037c   f5             PUSH AF
                        
   037d   3e 20          LD A, 020H ; End of Interrupt
   037f   d3 00          OUT (I8259A), A
                        
   0381   f1             POP AF
   0382   fb             EI
   0383   c9             RET
                        
                        ;------------------
                        
   0384                 ISR2
   0384   f5             PUSH AF
                        
   0385   3e 20          LD A, 020H ; End of Interrupt
   0387   d3 00          OUT (I8259A), A
                        
   0389   f1             POP AF
   038a   fb             EI
   038b   c9             RET
                        
                        ;------------------
                        
   038c                 ISR3
   038c   f5             PUSH AF
                        
   038d   3e 20          LD A, 020H ; End of Interrupt
   038f   d3 00          OUT (I8259A), A
                        
   0391   f1             POP AF
   0392   fb             EI
   0393   c9             RET
                        
                        ;------------------
                        
   0394                 ISR4
   0394   f5             PUSH AF
                        
   0395   3e 20          LD A, 020H ; End of Interrupt
   0397   d3 00          OUT (I8259A), A
                        
   0399   f1             POP AF
   039a   fb             EI
   039b   c9             RET
                        
                        ;------------------
                        
   039c                 ISR5
   039c   f5             PUSH AF
                        
   039d   3e 20          LD A, 020H ; End of Interrupt
   039f   d3 00          OUT (I8259A), A
                        
   03a1   f1             POP AF
   03a2   fb             EI
   03a3   c9             RET
                        
                        ;------------------
                        
   03a4                 ISR6
   03a4   f5             PUSH AF
                        
   03a5   3e 20          LD A, 020H ; End of Interrupt
   03a7   d3 00          OUT (I8259A), A
                        
   03a9   f1             POP AF
   03aa   fb             EI
   03ab   c9             RET
                        
                        ;------------------
                        
   03ac                 ISR7
   03ac   f5             PUSH AF
                        
   03ad   3e 20          LD A, 020H ; End of Interrupt
   03af   d3 00          OUT (I8259A), A
                        
   03b1   f1             POP AF
   03b2   fb             EI
   03b3   c9             RET
                        
                        ;----------------------------------------
                        
   03b4   50 49 43 31   INTROSTR DB "PIC16C64 test", 10, 0
   03b8   36 43 36 34   
   03bc   20 74 65 73   
   03c0   74 0a 00      
                        
   03c3   59 6f 75 72   PLEASESTR DB "Your name?", 10, 0
   03c7   20 6e 61 6d   
   03cb   65 3f 0a 00   
   03cf   48 65 6c 6c   HELLOSTR DB "Hello ", 0
   03d3   6f 20 00      
                        
   03d6                 KEY_XLAT ; Normal, shift, ctrl, alt
   03d6   3f 3f 3f 3f    DB '?', '?', '?', '?'
   03da   39 39 39 39    DB '9', '9', '9', '9' ; F9
   03de   3f 3f 3f 3f    DB '?', '?', '?', '?'
   03e2   35 35 35 35    DB '5', '5', '5', '5' ; F5
   03e6   33 33 33 33    DB '3', '3', '3', '3' ; F3
   03ea   31 31 31 31    DB '1', '1', '1', '1' ; F1
   03ee   32 32 32 32    DB '2', '2', '2', '2' ; F2
   03f2   31 31 31 31    DB '1', '1', '1', '1' ; F12
   03f6   3f 3f 3f 3f    DB '?', '?', '?', '?'
   03fa   31 31 31 31    DB '1', '1', '1', '1' ; F10
   03fe   38 38 38 38    DB '8', '8', '8', '8' ; F8
   0402   36 36 36 36    DB '6', '6', '6', '6' ; F6
   0406   34 34 34 34    DB '4', '4', '4', '4' ; F4
   040a   09 09 09 09    DB 9, 9, 9, 9 ; Tab
   040e   60 7e 60 60    DB '`', '~', '`', '`'
   0412   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0416   3f 3f 3f 3f    DB '?', '?', '?', '?'
   041a   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Alt
   041e   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Left shift
   0422   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0426   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Control
   042a   71 51 11 11    DB 'q', 'Q', 17, 17
   042e   31 21 31 31    DB '1', '!', '1', '1'
   0432   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0436   3f 3f 3f 3f    DB '?', '?', '?', '?'
   043a   3f 3f 3f 3f    DB '?', '?', '?', '?'
   043e   7a 5a 1a 1a    DB 'z', 'Z', 26, 26
   0442   73 53 13 13    DB 's', 'S', 19, 19
   0446   61 41 01 01    DB 'a', 'A', 1, 1
   044a   77 57 17 17    DB 'w', 'W', 23, 23
   044e   32 40 32 32    DB '2', '@', '2', '2'
   0452   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0456   3f 3f 3f 3f    DB '?', '?', '?', '?'
   045a   63 43 03 03    DB 'c', 'C', 3, 3
   045e   78 58 18 18    DB 'x', 'X', 24, 24
   0462   64 44 04 04    DB 'd', 'D', 4, 4
   0466   65 45 05 05    DB 'e', 'E', 5, 5
   046a   34 24 34 34    DB '4', '$', '4', '4'
   046e   33 23 33 33    DB '3', '#', '3', '3'
   0472   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0476   3f 3f 3f 3f    DB '?', '?', '?', '?'
   047a   20 20 20 20    DB ' ', ' ', ' ', ' '
   047e   76 56 16 16    DB 'v', 'V', 22, 22
   0482   66 46 06 06    DB 'f', 'F', 6, 6
   0486   74 54 14 14    DB 't', 'T', 20, 20
   048a   72 52 12 12    DB 'r', 'R', 18, 18
   048e   35 25 35 35    DB '5', '%', '5', '5'
   0492   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0496   3f 3f 3f 3f    DB '?', '?', '?', '?'
   049a   6e 4e 0e 0e    DB 'n', 'N', 14, 14
   049e   62 42 02 02    DB 'b', 'B', 2, 2
   04a2   68 48 08 08    DB 'h', 'H', 8, 8
   04a6   67 47 07 07    DB 'g', 'G', 7, 7
   04aa   79 59 19 19    DB 'y', 'Y', 25, 25
   04ae   36 5e 36 36    DB '6', '^', '6', '6'
   04b2   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04b6   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04ba   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04be   6d 4d 0d 0d    DB 'm', 'M', 13, 13
   04c2   6a 4a 0a 0a    DB 'j', 'J', 10, 10
   04c6   75 55 15 15    DB 'u', 'U', 21, 21
   04ca   37 26 37 37    DB '7', '&', '7', '7'
   04ce   38 2a 38 38    DB '8', '*', '8', '8'
   04d2   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04d6   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04da   2c 3c 2c 2c    DB ',', '<', ',', ','
   04de   6b 4b 0b 0b    DB 'k', 'K', 11, 11
   04e2   69 49 09 09    DB 'i', 'I', 9, 9
   04e6   6f 4f 0f 0f    DB 'o', 'O', 15, 15
   04ea   30 29 30 30    DB '0', ')', '0', '0'
   04ee   39 28 39 39    DB '9', '(', '9', '9'
   04f2   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04f6   3f 3f 3f 3f    DB '?', '?', '?', '?'
   04fa   2e 3e 2e 2e    DB '.', '>', '.', '.'
   04fe   2f 3f 2f 2f    DB '/', '?', '/', '/'
   0502   6c 4c 0c 0c    DB 'l', 'L', 12, 12
   0506   3b 3a 3b 3b    DB ';', ':', ';', ';'
   050a   70 50 10 10    DB 'p', 'P', 16, 16
   050e   2d 5f 2d 2d    DB '-', '_', '-', '-'
   0512   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0516   3f 3f 3f 3f    DB '?', '?', '?', '?'
   051a   3f 3f 3f 3f    DB '?', '?', '?', '?'
   051e   27 22 27 27    DB 39, '"', 39, 39 ; Single quote
   0522   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0526   5b 7b 5b 5b    DB '[', '{', '[', '['
   052a   3d 2b 3d 3d    DB '=', '+', '=', '='
   052e   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0532   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0536   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Caps lock
   053a   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Right shift
   053e   0a 0a 0a 0a    DB 10, 10, 10, 10 ; Enter
   0542   5d 7d 5d 5d    DB ']', '}', ']', ']'
   0546   3f 3f 3f 3f    DB '?', '?', '?', '?'
   054a   5c 7c 5c 5c    DB 92, '|', 92, 92 ; Backslash
   054e   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0552   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0556   3f 3f 3f 3f    DB '?', '?', '?', '?'
   055a   3f 3f 3f 3f    DB '?', '?', '?', '?'
   055e   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0562   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0566   3f 3f 3f 3f    DB '?', '?', '?', '?'
   056a   3f 3f 3f 3f    DB '?', '?', '?', '?'
   056e   08 08 08 08    DB 8, 8, 8, 8 ; Backspace
   0572   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0576   3f 3f 3f 3f    DB '?', '?', '?', '?'
   057a   31 31 31 31    DB '1', '1', '1', '1' ; Numeric 1
   057e   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0582   34 34 34 34    DB '4', '4', '4', '4' ; Numeric 4
   0586   37 37 37 37    DB '7', '7', '7', '7' ; Numeric 7
   058a   3f 3f 3f 3f    DB '?', '?', '?', '?'
   058e   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0592   3f 3f 3f 3f    DB '?', '?', '?', '?'
   0596   30 30 30 30    DB '0', '0', '0', '0' ; Numeric 0
   059a   2e 2e 2e 2e    DB '.', '.', '.', '.' ; Numeric .
   059e   32 32 32 32    DB '2', '2', '2', '2' ; Numeric 2
   05a2   35 35 35 35    DB '5', '5', '5', '5' ; Numeric 5
   05a6   36 36 36 36    DB '6', '6', '6', '6' ; Numeric 6
   05aa   38 38 38 38    DB '8', '8', '8', '8' ; Numeric 8
   05ae   1b 1b 1b 1b    DB 27, 27, 27, 27 ; Escape
   05b2   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Num lock
   05b6   31 31 31 31    DB '1', '1', '1', '1' ; F11
   05ba   2b 2b 2b 2b    DB '+', '+', '+', '+' ; Numeric +
   05be   33 33 33 33    DB '3', '3', '3', '3' ; Numeric 3
   05c2   2d 2d 2d 2d    DB '-', '-', '-', '-' ; Numeric -
   05c6   2a 2a 2a 2a    DB '*', '*', '*', '*' ; Numeric *
   05ca   39 39 39 39    DB '9', '9', '9', '9' ; Numeric 9
   05ce   3f 3f 3f 3f    DB '?', '?', '?', '?' ; Scroll lock
   05d2   3f 3f 3f 3f    DB '?', '?', '?', '?'
                        
   3000                  ORG 03000H
                        
   3000                 ZCCOUT
                        
   3000   3e 00          LD A, 0
   3002   32 0d 80       LD (SHOULD_RUN), A
   3005   cd 09 30       CALL _main
   3008   76             HALT
                        
                        
                         ;
                         ; Function "main".
                         ;
   3009                 _main
   3009   fd e5          PUSH IY
   300b   fd 21 00 00    LD IY, 0
   300f   fd 39          ADD IY, SP
   3011   21 e2 ff       LD HL, -30
   3014   39             ADD HL, SP
   3015   f9             LD SP, HL
                         ; Variable "buffer" is at location IY - 30
                        
                         ; (tst.c, 66) }
   3016                 zcc$3
                         ; (tst.c, 62) while (1) {
   3016   21 01 00       LD HL, 1
   3019   b7             OR A
   301a   11 00 00       LD DE, 0
   301d   ed 52          SBC HL, DE
   301f   ca 4e 30       JP Z, zcc$4
                         ; (tst.c, 63) printf("What's your name?\n");
   3022   21 69 30       LD HL, zcc$1
   3025   e5             PUSH HL
   3026   cd 7c 30       CALL _printf
   3029   33             INC SP
   302a   33             INC SP
                        
                         ; (tst.c, 64) gets(buffer);
   302b   01 e2 ff       LD BC, -30
   302e   fd e5          PUSH IY
   3030   e1             POP HL
   3031   09             ADD HL, BC
   3032   e5             PUSH HL
   3033   cd 05 32       CALL _gets
   3036   33             INC SP
   3037   33             INC SP
                        
                         ; (tst.c, 65) printf("Hey there %s\n", buffer);
   3038   01 e2 ff       LD BC, -30
   303b   fd e5          PUSH IY
   303d   e1             POP HL
   303e   09             ADD HL, BC
   303f   e5             PUSH HL
   3040   21 5b 30       LD HL, zcc$2
   3043   e5             PUSH HL
   3044   cd 7c 30       CALL _printf
   3047   33             INC SP
   3048   33             INC SP
   3049   33             INC SP
   304a   33             INC SP
   304b   c3 16 30       JP zcc$3
   304e                 zcc$4
                        
   304e   fd f9          LD SP, IY
   3050   fd e1          POP IY
                        
   3052   c9             RET
                        
   3053   00 00         _src DW 0
   3055   00 00         _dst DW 0
   3057   00 00         _buffer DW 0
   3059   00 00         _format DW 0
                        
   305b   48 65 79 20   zcc$2 DB "Hey there %s", 10, 0
   305f   74 68 65 72   
   3063   65 20 25 73   
   3067   0a 00         
   3069   57 68 61 74   zcc$1 DB "What's your name?", 10, 0
   306d   27 73 20 79   
   3071   6f 75 72 20   
   3075   6e 61 6d 65   
   3079   3f 0a 00      
                        
                        ; functions that look kinda like libc functions
                        
                        
                        
                        ;
                        ; int printf(char *format, ...) -- just like C
                        ;
                        ; Only supports %d, %x, and %s
                        ;
                        ; internally:
                        ; HL = pointer to format string
                        ; IX = pointer to output buffer
                        ; IY = pointer to next arg to be processed
                        ;
                        
   307c                 _printf
   307c   fd e5          PUSH IY
   307e   fd 21 00 00    LD IY, 0
   3082   fd 39          ADD IY, SP
                        
   3084   f5             PUSH AF
   3085   dd e5          PUSH IX
                        
                         ; IY points at IY on stack
   3087   fd 23          INC IY
   3089   fd 23          INC IY ; points at return address
   308b   fd 23          INC IY
   308d   fd 23          INC IY ; points at first argument (format string)
                        
   308f   fd 6e 00       LD L, (IY + 0) ; format string into HL
   3092   fd 66 01       LD H, (IY + 1)
   3095   fd 23          INC IY
   3097   fd 23          INC IY ; points at next argument (first after format string)
                        
   3099   dd 21 88 88    LD IX, PRINTF_BUF
                        
   309d                 PRINTF_LOOP
   309d   7e             LD A, (HL)
   309e   fe 25          CP '%'
   30a0   c2 c9 30       JP NZ, PRINTF_NOT_PERCENT
                        
   30a3   23             INC HL
   30a4   7e             LD A, (HL)
   30a5   fe 64          CP 'd'
   30a7   c2 b1 30       JP NZ, PRINTF_NOT_DECIMAL
                        
   30aa   cd e3 30       CALL PRINTF_CONVERT_DECIMAL
                        
   30ad   23             INC HL
   30ae   c3 9d 30       JP PRINTF_LOOP
                        
   30b1                 PRINTF_NOT_DECIMAL
   30b1   fe 78          CP 'x'
   30b3   c2 bd 30       JP NZ, PRINTF_NOT_HEX
                        
   30b6   cd e5 31       CALL PRINTF_CONVERT_HEX
                        
   30b9   23             INC HL
   30ba   c3 9d 30       JP PRINTF_LOOP
                        
   30bd                 PRINTF_NOT_HEX
   30bd   fe 73          CP 's'
   30bf   c2 c9 30       JP NZ, PRINTF_NOT_PERCENT
                        
   30c2   cd f5 31       CALL PRINTF_CONVERT_STRING
                        
   30c5   23             INC HL
   30c6   c3 9d 30       JP PRINTF_LOOP
                        
   30c9                 PRINTF_NOT_PERCENT
   30c9   dd 77 00       LD (IX), A
   30cc   dd 23          INC IX
   30ce   23             INC HL
   30cf   fe 00          CP 0
   30d1   c2 9d 30       JP NZ, PRINTF_LOOP
                        
   30d4   21 88 88       LD HL, PRINTF_BUF
   30d7   cd 89 00       CALL LCDPRINT
   30da   21 00 00       LD HL, 0
                        
   30dd   dd e1          POP IX
   30df   f1             POP AF
   30e0   fd e1          POP IY
                        
   30e2   c9             RET
                        
                        ;PRINTF_BUF DS 48 ; 24 bytes on the display, pad to be sure
   8888                 PRINTF_BUF EQU 08888H
                        
                        ;
                        ; PRINTF_CONVERT_DECIMAL
                        ;
                        ; Input:
                        ; IY = pointer to int
                        ; IX = buffer to convert into
                        ; Output:
                        ; IY = incremented past int
                        ; IX = incremented past decimal version of int
                        ; Internally:
                        ; HL = int
                        ;
                        
   30e3                 PRINTF_CONVERT_DECIMAL
   30e3   e5             PUSH HL
   30e4   f5             PUSH AF
   30e5   c5             PUSH BC
                        
   30e6   fd 6e 00       LD L, (IY + 0)
   30e9   fd 66 01       LD H, (IY + 1)
   30ec   fd 23          INC IY
   30ee   fd 23          INC IY
                        
   30f0   af             XOR A ; reset carry and set A to 0
   30f1   47             LD B, A ; BC = 0
   30f2   4f             LD C, A
   30f3   ed 4a          ADC HL, BC ; HL = HL (set zero flag)
   30f5   c2 02 31       JP NZ, PCD_NOT_ZERO
                        
   30f8   3e 30          LD A, '0'
   30fa   dd 77 00       LD (IX), A
   30fd   dd 23          INC IX
                        
   30ff   c3 56 31       JP PCD_END
                        
   3102                 PCD_NOT_ZERO
   3102   fd e5          PUSH IY
   3104   d5             PUSH DE
                        
   3105   3e 00          LD A, 0 ; D = 0 (printed flag)
   3107   57             LD D, A
                        
   3108   fd 21 5a 31    LD IY, PCD_TABLE
                        
   310c                 PCD_LOOP
   310c   fd 7e 00       LD A, (IY)
   310f   fd 23          INC IY ; does not affect condition bits
   3111   fe 24          CP '$' ; end of table
   3113   ca 53 31       JP Z, PCD_LOOP_END
                        
   3116   fd 4e 00       LD C, (IY) ; get word to compare to
   3119   fd 23          INC IY
   311b   fd 46 00       LD B, (IY)
   311e   fd 23          INC IY
                        
   3120   fe 30          CP '0' ; special case
   3122   c2 3d 31       JP NZ, PCD_NOT_ZERO_DIGIT
                        
   3125   7a             LD A, D ; printed flag
   3126   fe 00          CP 0
   3128   ca 0c 31       JP Z, PCD_LOOP ; before first digit, do not print zero
                        
                         ; the number in BC represents the smallest number which HL
                         ; has to be to not print a zero right now
   312b   a7             AND A ; clear carry
   312c   e5             PUSH HL ; do not clobber it
   312d   ed 42          SBC HL, BC ; HL -= BC
   312f   e1             POP HL
   3130   d2 0c 31       JP NC, PCD_LOOP ; HL >= BC
                        
   3133   3e 30          LD A, '0' ; print zero
   3135   dd 77 00       LD (IX), A
   3138   dd 23          INC IX
   313a   c3 0c 31       JP PCD_LOOP
                        
   313d                 PCD_NOT_ZERO_DIGIT
   313d   a7             AND A ; clear carry
   313e   e5             PUSH HL ; do not clobber HL
   313f   ed 42          SBC HL, BC ; HL -= BC
   3141   e1             POP HL
   3142   da 0c 31       JP C, PCD_LOOP ; HL < BC
                        
   3145   dd 77 00       LD (IX), A ; print digit
   3148   dd 23          INC IX
                        
   314a   a7             AND A ; clear carry
   314b   ed 42          SBC HL, BC ; HL -= BC
                        
   314d   3e 01          LD A, 1 ; printed flag = 1
   314f   57             LD D, A
                        
   3150   c3 0c 31       JP PCD_LOOP
                        
   3153                 PCD_LOOP_END
   3153   d1             POP DE
   3154   fd e1          POP IY
                        
   3156                 PCD_END
   3156   c1             POP BC
   3157   f1             POP AF
   3158   e1             POP HL
   3159   c9             RET
                        
   315a                 PCD_TABLE
   315a   36             DB '6'
   315b   60 ea          DW 60000
   315d   35             DB '5'
   315e   50 c3          DW 50000
   3160   34             DB '4'
   3161   40 9c          DW 40000
   3163   33             DB '3'
   3164   30 75          DW 30000
   3166   32             DB '2'
   3167   20 4e          DW 20000
   3169   31             DB '1'
   316a   10 27          DW 10000
   316c   30             DB '0'
   316d   e8 03          DW 1000
   316f   39             DB '9'
   3170   28 23          DW 9000
   3172   38             DB '8'
   3173   40 1f          DW 8000
   3175   37             DB '7'
   3176   58 1b          DW 7000
   3178   36             DB '6'
   3179   70 17          DW 6000
   317b   35             DB '5'
   317c   88 13          DW 5000
   317e   34             DB '4'
   317f   a0 0f          DW 4000
   3181   33             DB '3'
   3182   b8 0b          DW 3000
   3184   32             DB '2'
   3185   d0 07          DW 2000
   3187   31             DB '1'
   3188   e8 03          DW 1000
   318a   30             DB '0'
   318b   64 00          DW 100
   318d   39             DB '9'
   318e   84 03          DW 900
   3190   38             DB '8'
   3191   20 03          DW 800
   3193   37             DB '7'
   3194   bc 02          DW 700
   3196   36             DB '6'
   3197   58 02          DW 600
   3199   35             DB '5'
   319a   f4 01          DW 500
   319c   34             DB '4'
   319d   90 01          DW 400
   319f   33             DB '3'
   31a0   2c 01          DW 300
   31a2   32             DB '2'
   31a3   c8 00          DW 200
   31a5   31             DB '1'
   31a6   64 00          DW 100
   31a8   30             DB '0'
   31a9   0a 00          DW 10
   31ab   39             DB '9'
   31ac   5a 00          DW 90
   31ae   38             DB '8'
   31af   50 00          DW 80
   31b1   37             DB '7'
   31b2   46 00          DW 70
   31b4   36             DB '6'
   31b5   3c 00          DW 60
   31b7   35             DB '5'
   31b8   32 00          DW 50
   31ba   34             DB '4'
   31bb   28 00          DW 40
   31bd   33             DB '3'
   31be   1e 00          DW 30
   31c0   32             DB '2'
   31c1   14 00          DW 20
   31c3   31             DB '1'
   31c4   0a 00          DW 10
   31c6   30             DB '0'
   31c7   01 00          DW 1
   31c9   39             DB '9'
   31ca   09 00          DW 9
   31cc   38             DB '8'
   31cd   08 00          DW 8
   31cf   37             DB '7'
   31d0   07 00          DW 7
   31d2   36             DB '6'
   31d3   06 00          DW 6
   31d5   35             DB '5'
   31d6   05 00          DW 5
   31d8   34             DB '4'
   31d9   04 00          DW 4
   31db   33             DB '3'
   31dc   03 00          DW 3
   31de   32             DB '2'
   31df   02 00          DW 2
   31e1   31             DB '1'
   31e2   01 00          DW 1
   31e4   24             DB '$'
                        
                        ;
                        ; PRINTF_CONVERT_HEX
                        ;
                        ; Input:
                        ; IY = pointer to int
                        ; IX = buffer to convert into
                        ; Output:
                        ; IY = incremented past int
                        ; IX = incremented past hex version of int
                        ; Internally:
                        ; HL = int
                        ;
                        
   31e5                 PRINTF_CONVERT_HEX
   31e5   e5             PUSH HL
                        
   31e6   fd 6e 00       LD L, (IY + 0)
   31e9   fd 66 01       LD H, (IY + 1)
   31ec   fd 23          INC IY
   31ee   fd 23          INC IY
                        
   31f0   cd 2d 01       CALL PHEXWORD
                        
   31f3   e1             POP HL
   31f4   c9             RET
                        
                        ;
                        ; PRINTF_CONVERT_STRING
                        ;
                        ; Input:
                        ; IY = pointer to string pointer
                        ; IX = buffer to convert into
                        ; Output:
                        ; IY = incremented past pointer
                        ; IX = incremented past string
                        ;
                        
   31f5                 PRINTF_CONVERT_STRING
   31f5   e5             PUSH HL
                        
   31f6   fd 6e 00       LD L, (IY + 0)
   31f9   fd 66 01       LD H, (IY + 1)
   31fc   fd 23          INC IY
   31fe   fd 23          INC IY
                        
   3200   cd b8 01       CALL STRCPY ; increments IX for us
                        
   3203   e1             POP HL
   3204   c9             RET
                        
                        ;
                        ; char *gets(char *buffer) -- just like C
                        ;
                        
                        
   3205                 _gets
   3205   fd e5          PUSH IY
   3207   fd 21 00 00    LD IY, 0
   320b   fd 39          ADD IY, SP
                        
   320d   fd 6e 04       LD L, (IY + 4) ; buffer into HL
   3210   fd 66 05       LD H, (IY + 5)
                        
   3213   e5             PUSH HL
   3214   cd 38 01       CALL GETS
   3217   e1             POP HL ; so that return value is buffer
                        
   3218   fd e1          POP IY
                        
   321a   c9             RET
                        
                        ;
                        ; char *strcpy(char *dst, char *src) -- just like C
                        ;
                        
                        
   321b                 _strcpy
   321b   fd e5          PUSH IY
   321d   fd 21 00 00    LD IY, 0
   3221   fd 39          ADD IY, SP
   3223   f5             PUSH AF
   3224   dd e5          PUSH IX
                        
   3226   fd 6e 04       LD L, (IY + 4) ; destination into IX
   3229   fd 66 05       LD H, (IY + 5)
   322c   e5             PUSH HL
   322d   e5             PUSH HL
   322e   dd e1          POP IX
                        
   3230   fd 6e 06       LD L, (IY + 6) ; source into HL
   3233   fd 66 07       LD H, (IY + 7)
                        
   3236                 STRCPY_NEXT_BYTE
   3236   7e             LD A, (HL)
   3237   dd 77 00       LD (IX), A
   323a   23             INC HL
   323b   dd 23          INC IX
                        
   323d   fe 00          CP 0
   323f   c2 36 32       JP NZ, STRCPY_NEXT_BYTE
                        
   3242   e1             POP HL ; return the destination
                        
   3243   dd e1          POP IX
   3245   f1             POP AF
   3246   fd e1          POP IY
                        
   3248   c9             RET
                        
   3f00                  ORG 03F00H
   3f00                 INTTABLE
                        
                         ; IRQ0
   3f00   c3 2e 02       JP ISR0
   3f03   00             DB 0
                        
                         ; IRQ1
   3f04   c3 7c 03       JP ISR1
   3f07   00             DB 0
                        
                         ; IRQ2
   3f08   c3 84 03       JP ISR2
   3f0b   00             DB 0
                        
                         ; IRQ3
   3f0c   c3 8c 03       JP ISR3
   3f0f   00             DB 0
                        
                         ; IRQ4
   3f10   c3 94 03       JP ISR4
   3f13   00             DB 0
                        
                         ; IRQ5
   3f14   c3 9c 03       JP ISR5
   3f17   00             DB 0
                        
                         ; IRQ6
   3f18   c3 a4 03       JP ISR6
   3f1b   00             DB 0
                        
                         ; IRQ7
   3f1c   c3 ac 03       JP ISR7
   3f1f   00             DB 0
                        
   3f20                  END
0011  ALT_KEY       8006  ALT_STATUS    0171  BACKSPACE     0003  CMD_MAX   
0002  CMD_RUN       0001  CMD_SEND      0014  CTRL_KEY      8005  CTRL_STATUS
8009  CURRENT_ADDR    8008  CURRENT_CMD    800b  CURRENT_LEN    800c  CURRENT_PTR
0374  DID_KEY       0111  DIG1DONE      010f  DIG1LESS      0125  DIG2DONE  
0123  DIG2LESS      0379  END_HANDLE_KEYBOARD    02e4  END_HANDLE_SERIAL    00e1  EXT2_KEY  
00e0  EXT_KEY       0138  GETS          0164  GETS_COPY     01a5  GETS_DONE 
0147  GETS_LOOP     028c  GET_CMD_HEADER    003f  GOTRESETSTR    015b  GOT_KEY   
02e7  HANDLE_KEYBOARD    0272  HANDLE_SERIAL    03cf  HELLOSTR      0000  I8259A    
0001  I8259B        c000  INPUT_BUF     03b4  INTROSTR      3f00  INTTABLE  
022e  ISR0          026b  ISR0_END      0249  ISR0_IS_COMMAND    0260  ISR0_IS_KEYBOARD
025a  ISR0_IS_SERIAL    0257  ISR0_IS_TIMER    0266  ISR0_RESET    037c  ISR1      
0384  ISR2          038c  ISR3          0394  ISR4          039c  ISR5      
03a4  ISR6          03ac  ISR7          0312  IS_SHIFT      a000  KEYBUF    
03d6  KEY_XLAT      0061  LCDCLR        0003  LCDDATA       004c  LCDINIT   
0002  LCDINST       00a5  LCDNOSWITCH    00ce  LCDP1LOOP     00b2  LCDP1SL1  
00b4  LCDP1SL2      00b6  LCDP1SL3      00e7  LCDP1SLP1     00e9  LCDP1SLP2 
00eb  LCDP1SLP3     00a3  LCDP2LOOP     0093  LCDPCLOOP     00d5  LCDPDOIT  
00df  LCDPDONE      0099  LCDPLOOP      00db  LCDPNEXT      00c6  LCDPNLOOP 
0089  LCDPRINT      00d9  LCDPWLOOP     0001  LCLEAR        007f  LCSTRING  
0005  LCSTRLEN      0080  LHALF1        00c0  LHALF2        006b  LISTRING  
000a  LISTRLEN      0038  LRESET        0012  LSHIFT_KEY    01cb  MAIN      
0187  NEXT_KEY      033d  NOT_ALT       0182  NOT_BACKSPACE    032d  NOT_CTRL  
031d  NOT_SHIFT     02f9  NOT_UP_KEY    8001  NUMKEY        0058  OUTBLOOP  
0056  OUTBYTES      c040  OUTPUT_BUF    000a  PAUSE         3156  PCD_END   
310c  PCD_LOOP      3153  PCD_LOOP_END    3102  PCD_NOT_ZERO    313d  PCD_NOT_ZERO_DIGIT
315a  PCD_TABLE     00f8  PHEXBYTE      012d  PHEXWORD      0004  PIC       
8003  PICBYTE       8000  PIC_COMMAND    0002  PIC_KBD_CMD    0000  PIC_NON_CMD
0001  PIC_SER_CMD    0003  PIC_TIM_CMD    03c3  PLEASESTR     01ff  PRINTAGAIN
8888  PRINTF_BUF    30e3  PRINTF_CONVERT_DECIMAL    31e5  PRINTF_CONVERT_HEX    31f5  PRINTF_CONVERT_STRING
309d  PRINTF_LOOP    30b1  PRINTF_NOT_DECIMAL    30bd  PRINTF_NOT_HEX    30c9  PRINTF_NOT_PERCENT
0059  RSHIFT_KEY    8004  SHIFT_STATUS    800d  SHOULD_RUN    02d2  SIMULATE_KEYBOARD
0000  STACKTOP      01b8  STRCPY        01ba  STRCPY_LOOP    3236  STRCPY_NEXT_BYTE
02b7  TRANSFER_BYTE    02a1  TRANSFER_HEADER    8007  UPKEY_FLAG    00f0  UP_KEY    
00e4  WAITSECS      3000  ZCCOUT        3057  _buffer       3055  _dst      
3059  _format       3205  _gets         3009  _main         307c  _printf   
3053  _src          321b  _strcpy       3069  zcc$1         305b  zcc$2     
3016  zcc$3         304e  zcc$4         
